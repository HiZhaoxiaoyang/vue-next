<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>computed</title>
</head>
<body>
    <script src="../../packages/reactivity/dist/reactivity.global.js"></script>
    <script>
        const { computed, reactive, effect, stop, ref, WritableComputedRef } = VueObserver
        
        // should return updated value

        // const value = reactive({})
        // const cValue = computed(() => {
        //     return value.foo
        // })
        // console.log(cValue.value)
        // value.foo = 1
        // console.log(cValue.value)






        // should compute lazily

        // const value = reactive({})
        // const getter = () => {
        //     return value.foo
        // }
        // const cValue = computed(getter)

        // // getter没被调用
        // console.log(cValue.value)
        // // getter调用1次

        // console.log(cValue.value)
        // // getter不会执行 因为 dirty是false

        // value.foo = 1
        // // getter 不会调用,等到下次value.foo求值时才会调用

        // console.log(value.foo)
        // // getter 调用1次

        // console.log(cValue.value)
        // // getter 调用1次





        // should trigger effect

        // const value = reactive({})
        // const cValue = computed(() => {
        //     return value.foo
        // })
        // let dummy
        // effect(() => {
        //     dummy = cValue.value
        // })
        // console.log(dummy)
        // value.foo = 1
        // console.log(dummy)






        // should work when chained

        // const value = reactive({ foo: 0 })
        // const c1 = computed(() => {
        //     return value.foo
        // })
        // const c2 = computed(() => {
        //     return c1.value + 1
        // })
        // console.log(c2.value)
        // console.log(c1.value)

        // value.foo++
        // console.log(c2.value)
        // console.log(c1.value)






        // should trigger effect when chained

        // const value = reactive({ foo: 0 })
        // const getter1 = () => {
        //     return value.foo
        // }
        // const getter2 = () => {
        //     return c1.value + 1
        // }
        // const c1 = computed(getter1)
        // const c2 = computed(getter2)

        // let dummy
        // effect(() => {
        //     dummy = c2.value
        // })

        // console.log(dummy)
        // // getter1 getter2 各调用一次

        // value.foo++
        // console.log(dummy)
        // // getter1 getter2 各调用一次

        




        // should trigger effect when chained (mixed invocations)

        // const value = reactive({ foo: 0 })
        // const getter1 = () => {
        //     return value.foo
        // }
        // const getter2 = () => {
        //     return c1.value + 1
        // }
        // const c1 = computed(getter1)
        // const c2 = computed(getter2)

        // let dummy
        // effect(() => {
        //     dummy = c1.value + c2.value
        // })
        // console.log(dummy)
        // // getter1 getter2 各调用一次

        // value.foo++
        // console.log(dummy)
        // // getter1 getter2 各调用一次






        // should no longer update when stopped

        // const value = reactive({})
        // const cValue = computed(() => {
        //     return value.foo
        // })
        // let dummy
        // effect(() => {
        //     dummy = cValue.value
        // })
        // console.log(dummy)

        // value.foo = 1
        // console.log(dummy)
        // stop(cValue.effect)
        // value.foo = 2
        // console.log(dummy)







        // should support setter

        // const n = ref(1)
        // const plusOne = computed({
        //     get: () => {
        //         return n.value + 1
        //     },
        //     set: val => {
        //         n.value = val - 1
        //     }
        // })

        // console.log(plusOne.value)
        // n.value++
        // console.log(plusOne.value)
        // plusOne.value = 0
        // console.log(n.value)






        // should trigger effect w/ setter

        // const n = ref(1)
        // const plusOne = computed({
        //     get: () => {
        //         return n.value + 1
        //     },
        //     set: val => {
        //         n.value = val - 1
        //     }
        // })

        // let dummy
        // effect(() => {
        //     dummy = n.value
        // })

        // console.log(dummy)
        // plusOne.value = 0
        // console.log(dummy)






        // should warn if trying to set a readonly computed

        // Type cast to prevent TS from preventing the error
    </script>
</body>
</html>